
## Static Variables and Methods in Multithreading

### Static method
- Definition: Methods associated with the class, not with instances (objects).
- Can be called using the class name (e.g., `ClassName.methodName()`).
- Cannot access non-static instance variables or methods because they are not tied to a specific object.
- Declare a method static only if it perform computations based solely on their input arguments.

### Shared Static Variables
- A `static` variable belongs to the **class**, not to an instance.
- This means all objects and all threads **share the same variable**.
- Example:

```java
public class Calculation {
    static int price = 10;

    public void sum2(int a, int b) {
        price = a + b;
    }
}
```

- If multiple threads call `sum2`, they all modify the same `price`.  
- This can cause **race conditions** in multithreading.

### Making `sum2` Static
- Since `sum2` only modifies a `static` variable, it **can be made static**.
- Benefit: You can call it directly using the class name, without creating an object.

```java
Calculation.sum2(5, 6);
```

- Functionally both are the same, but making it `static` is better design here.

---

## Abstract Classes

### Abstract methods
- Declared in abstract classes and do not have a body.
- Must be implemented by subclasses, allowing for variable implementation across different subclasses.
- Provide a flexible design pattern when the specific implementation needs to be provided by subclasses.
- An abstract class **can contain both**:
  - **Abstract methods** (only declared, no body).
  - **Normal methods** (defined with a body).

Example:

```java
abstract class Animal {
    abstract void makeSound();  // abstract method

    void eat() {                // normal method
        System.out.println("Eating...");
    }
}
```

### Key Points About Abstract Classes
- Can contain:
  - Abstract methods ✅
  - Concrete (normal) methods ✅
  - Fields ✅
  - Constructors ✅
  - Static methods ✅
  - Final methods ✅
- **Cannot create objects** of an abstract class.

---

## Constructors in Abstract Classes

- Even though you cannot create an object of an abstract class directly,  
  its constructor is called when a subclass object is created.

Example:

```java
abstract class Animal {
    String name;

    Animal(String name) {   // constructor in abstract class
        this.name = name;
        System.out.println("Animal constructor called");
    }
}

class Dog extends Animal {
    Dog(String name) {
        super(name); // calls Animal constructor
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog("Tommy");
        // Output: Animal constructor called
    }
}
```

---

## Methods Without Body in Abstract Classes

- In Java:
  - A method **without a body** must be declared `abstract`.
  - A normal (non-abstract) method must have a body.

Example:

```java
abstract class Test {
    abstract void doSomething(); // ✅ valid abstract method

    void show() {               // ✅ valid normal method
        System.out.println("Hello");
    }

    // ❌ Invalid: method without body but not marked abstract
    // void wrongMethod(); 
}
```

---

## Final method
- Used to prevent overriding of a method in subclasses.
- If a method is declared as final, it maintains its original implementation in the parent class and cannot be changed in derived classes.

---

## Variable Arguments
- Allows methods to accept a variable number of arguments of a specified type.
- Declared using an ellipsis ... (e.g., `public void methodName(int... numbers)`).
- Rules
    - Varargs must be the last parameter in the method signature.
    - Helps to simplify method overloading when the number of parameters is uncertain.