# Pillars of Object-Oriented Programming (OOP)

1.  Abstraction
2.  Encapsulation
3.  Inheritance
    - Achieved using `extends` keyword or `interface`.
    - Types of Inheritance:
        1.  Single Inheritance
            - Class B inherits Class A
            - `B -> A`
        2.  Multilevel Inheritance
            - Class C inherits Class B
            - Class B inherits Class A
            - `C -> B -> A`
        3.  Hierarchical Inheritance
            - Class B inherits Class A
            - Class C inherits Class A
            - `B -> A`
            - `C -> A`
        4.  Multiple Inheritance
            - Not allowed in Java (Diamond Problem).
            - Diamond Problem: If two parent classes have a method with the same signature, the child class doesn’t know which one to inherit.
            - Even if the parent classes' methods have different names, Java doesn’t allow multiple inheritance using `extends`.
            - Workaround: Use interfaces. A class can implement multiple interfaces.
            - Class C inherits Class A
            - Class C inherits Class B
            - `C -> A`
            - `C -> B`

            Examples:

            Illegal multiple class inheritance (compile error):

            ```java
            class A { void aMethod() {} }
            class B { void bMethod() {} }

            // This is illegal in Java:
            // class C extends A, B { } // compile-time error
            ```

            Allowed alternatives using interfaces:

            ```java
            interface IA { void a(); }
            interface IB { void b(); }

            class C implements IA, IB {
                public void a() { /* implementation */ }
                public void b() { /* implementation */ }
            }
            ```

4.  Polymorphism
    - Poly means many, and morphism means form.
    - The same method behaves differently in different situations.
    - Types of Polymorphism:
        1.  Compile-time / Static Polymorphism / Method Overloading
            - Method overloading in Java is determined solely by the method signature, which consists of the method name and the number, type, and order of its parameters.
            - Examples:

            ```java
            class Adder {
                static int add(int a, int b) { return a + b; }
                static int add(int a, int b, int c) { return a + b + c; }
            }

            public class Main {
                public static void main(String[] args) {
                    System.out.println(Adder.add(11, 11));       // Output: 22
                    System.out.println(Adder.add(11, 11, 11));    // Output: 33
                }
            }
            ```

            -   **Important:** You cannot overload methods based on different return types alone. The rationale is that the return value alone is not sufficient for the compiler to figure out which function to call.

                ```java
                public class Example {
                    public int foo() { return 1; }
                    public float foo() { return 1.0f; } // Compile-time error: method foo() is already defined

                    public static void main(String[] args) {
                        Example ex = new Example();
                        // ex.foo(); // which one? - ambiguous call if the second foo() was allowed
                    }
                }
                ```

        2.  Run-time / Dynamic Polymorphism / Method Overriding
            -   Occurs when a subclass provides a specific implementation of a method that is already defined in its parent class.
            -   Examples:

            ```java
            class Animal {
                void makeSound() {
                    System.out.println("Generic animal sound");
                }
            }

            class Dog extends Animal {
                @Override
                void makeSound() {
                    System.out.println("Woof!");
                }
            }

            public class Main {
                public static void main(String[] args) {
                    Animal animal = new Animal();
                    Animal dog = new Dog();  // Upcasting

                    animal.makeSound();  // Output: Generic animal sound
                    dog.makeSound();       // Output: Woof!
                }
            }
            ```

---

# Object Relations

### Is-A Relationship (Inheritance)
- Represents a relationship where one class is a specialized version of another.
- It is implemented using inheritance.
- Example: A Dog is an Animal.

```java
class Animal {
    String name;
    void eat() { System.out.println("Eating"); }
}

class Dog extends Animal {
    void bark() { System.out.println("Woof!"); }
}

public class TestIsARelationship {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Inherited method
        dog.bark();  // Dog-specific method
    }
}
```

### Has-A Relationship (Association)
- Describes a relationship where one class contains or is associated with one or more objects of another class.
- It can be further categorized into different multiplicity types.

#### One-to-One Association
- One object of a class is associated with one object of another class.
  
```java
class Engine {
    void start() { System.out.println("Engine started"); }
}

class Car {
    Engine engine;  // A car has one engine

    Car(Engine engine) {
        this.engine = engine;
    }
}

public class TestOneToOne {
    public static void main(String[] args) {
        Engine engine = new Engine();
        Car car = new Car(engine);
        car.engine.start();
    }
}
```

#### One-to-Many Association
- One object of a class is associated with many objects of another class.
  
```java
import java.util.List;
import java.util.ArrayList;

class Teacher {
    String name;
    
    Teacher(String name) {
        this.name = name;
    }
}

class School {
    List<Teacher> teachers;  // A school has many teachers

    School() {
        teachers = new ArrayList<>();
    }

    void addTeacher(Teacher teacher) {
        teachers.add(teacher);
    }
}

public class TestOneToMany {
    public static void main(String[] args) {
        School school = new School();
        school.addTeacher(new Teacher("Mr. Smith"));
        school.addTeacher(new Teacher("Ms. Johnson"));
        school.teachers.forEach(t -> System.out.println(t.name));
    }
}
```

#### Many-to-Many Association
- Multiple objects of one class are associated with multiple objects of another class.
  
```java
import java.util.List;
import java.util.ArrayList;

class Student {
    String name;
    List<Course> courses;  // A student can enroll in many courses

    Student(String name) {
        this.name = name;
        courses = new ArrayList<>();
    }

    void enrollInCourse(Course course) {
        courses.add(course);
        course.students.add(this);
    }
}

class Course {
    String courseName;
    List<Student> students;  // A course can have many students

    Course(String courseName) {
        this.courseName = courseName;
        students = new ArrayList<>();
    }
}

public class TestManyToMany {
    public static void main(String[] args) {
        Student student1 = new Student("Alice");
        Student student2 = new Student("Bob");

        Course course = new Course("Java Programming");

        student1.enrollInCourse(course);
        student2.enrollInCourse(course);

        System.out.println("Students enrolled in " + course.courseName + ":");
        course.students.forEach(s -> System.out.println(s.name));
    }
}
```

---

### Aggregation
- A form of association that represents a "has-a" relationship with a whole-part relationship where the class/object can exist independently of the whole.
- Example: A department has students, but students can exist even if the department is deleted.

```java
import java.util.List;
import java.util.ArrayList;

class Student {
    String name;
    
    Student(String name) {
        this.name = name;
    }
}

class Department {
    String deptName;
    List<Student> students;  // Aggregation: Department has Students

    Department(String deptName) {
        this.deptName = deptName;
        students = new ArrayList<>();
    }

    void addStudent(Student student) {
        students.add(student);
    }
}

public class TestAggregation {
    public static void main(String[] args) {
        Department department = new Department("Computer Science");
        Student s1 = new Student("Alice");
        Student s2 = new Student("Bob");

        department.addStudent(s1);
        department.addStudent(s2);

        System.out.println("Department: " + department.deptName);
        department.students.forEach(s -> System.out.println("Student: " + s.name));
    }
}
```

### Composition
- A strong form of association where the object's lifecycle is managed by the whole; the object cannot exist independently.
- Example: A house consists of rooms; rooms don't exist without the house.

```java
import java.util.List;
import java.util.ArrayList;

class Room {
    String name;
    
    Room(String name) {
        this.name = name;
    }
}

class House {
    List<Room> rooms;  // Composition: House is responsible for creating/deleting Rooms

    House() {
        rooms = new ArrayList<>();
        // Creating rooms for the house
        rooms.add(new Room("Living Room"));
        rooms.add(new Room("Kitchen"));
    }
}

public class TestComposition {
    public static void main(String[] args) {
        House house = new House();
        System.out.println("House rooms:");
        house.rooms.forEach(room -> System.out.println(room.name));
    }
}
```