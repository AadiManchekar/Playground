## Java
- OOP
- Platform independent language (WORA) – Write Once, Run Anywhere.
- Components ([Read this](https://blog.bytebytego.com/i/172716141/how-java-works)):
    1. **JVM (Java Virtual Machine)**
        - JVM is platform dependent.
        - Java program → (Execute `javac <filename.java>`) → Bytecode (stored in a `.class` file) → (Pass through JVM) → Machine code → (executed by CPU) → Output.
        - The JVM includes a Just-In-Time (JIT) compiler which converts bytecode into machine code.
        - While the Java compiler converts source code into a universal bytecode format, the JVM is designed to run this bytecode on different operating systems.
        - Provides core Java functions such as memory management, garbage collection, and security.
    2. **JRE (Java Runtime Environment)**
        - JRE = JVM + class libraries (e.g., `java.lang`, `java.util`) + Java application launcher.
        - If you only want to execute a Java program, you can install just the JRE.
        - Read more: [Java Runtime Environment](https://aws.amazon.com/what-is/java-runtime-environment/)
    3. **JDK (Java Development Kit)**
        - The core component of the Java environment that provides all the tools, executables, and binaries (like `javac`, JShell, debugger) required to compile, debug, and execute a Java program.
        - JDK is platform dependent.
        - JDK = JRE + development tools.

---

### Question: What happens when I run `javac MyClass.java`?
**Answer:**  
The `javac` compiler translates your Java source code (`.java` file) into **bytecode** (a `.class` file).  
This bytecode is **platform-independent**, meaning it can run on any system with a JVM.

---

### Question: What does the JVM do with bytecode?
**Answer:**  
The JVM does not directly execute bytecode because:
- Bytecode is **not machine code**.
- CPUs understand only **native machine instructions** (e.g., x86, ARM).

So, the JVM must either **interpret** or **compile** the bytecode into native machine code.

---

### Question: How does the JVM execute bytecode?
**Answer:**  
The JVM uses two main strategies:
1. **Interpreter**  
   - Reads and executes bytecode **instruction by instruction**.
   - Works correctly but is slower (comparable to translating word by word).

2. **JIT Compiler (Just-In-Time)**  
   - Identifies frequently executed code (known as **hot code**).
   - Compiles that bytecode into **native machine code** at runtime.
   - Caches the compiled code so that subsequent executions run faster.

---

### Question: Isn’t the code already compiled by `javac`? Why compile again?
**Answer:**  
- `javac` compiles **Java source → Bytecode** (portable and not tied to any CPU).  
- The JVM’s JIT Compiler then compiles **Bytecode → Native Machine Code** that is specific to your CPU.  

This second compilation occurs at runtime to optimize and speed up program execution.

---

### Question: Why not compile everything to machine code upfront?
**Answer:**  
The JIT compiler uses **runtime information** to optimize, such as:
- Which methods are called most often.
- Specific CPU features available.
- Identification of "hot" loops or code paths.  

These optimizations often make JIT-compiled code faster than code compiled ahead-of-time.

---

### Question: What about AOT (Ahead-Of-Time) compilation?
**Answer:**  
With AOT compilation (e.g., **GraalVM Native Image**):
- Java bytecode is compiled **directly into native machine code before runtime**.
- This approach removes the need for a JIT compiler, reduces startup time, and produces smaller executables.
- However, some runtime optimizations provided by the JIT compiler may be lost.

---

### Question: Difference between compiling and interpreting?
**Answer:**  
- **Compilation**
    - Involves converting the entire source code (e.g., `.java` files) into machine code or bytecode in one go before the program is executed.
    - The output is typically a binary file or a bytecode file (e.g., a `.class` file in Java). This result is a standalone executable or bytecode that can be run on a specific platform, given the corresponding interpreter or runtime environment.
    - For example, Go is a compiled language. Go source code is translated directly into machine-level code by a compiler before execution. The compiler checks the source code for errors and produces a standalone executable binary file that can be directly executed by the operating system.
- **Interpretation**
    - Involves reading and executing the source code **line by line** at runtime.
    - The interpreter translates the code into machine language as the program is being executed rather than compiling the whole code beforehand.
    - No separate executable file is generated; the interpreter processes the code directly during execution.