## Concrete Class in Java

A **concrete class** is a class whose object can be created using the `new` keyword.

```java
// Example: Creating an object of a concrete class
public class Animal {
    public void speak() {
        System.out.println("Animal speaks");
    }
}

Animal a = new Animal(); // Object creation using 'new'
a.speak();
```

---

All methods in a concrete class must have an implementation.

```java
// Example: All methods have implementation
public class Dog {
    public void bark() {
        System.out.println("Woof!");
    }
}
```

---

It doesn't matter if the class is a child class, extends an abstract class, or implements an interface.

```java
// Example: Concrete class extending abstract class
abstract class Vehicle {
    abstract void drive();
}

public class Car extends Vehicle {
    @Override
    void drive() {
        System.out.println("Car is driving");
    }
}

// Example: Concrete class implementing interface
interface Flyable {
    void fly();
}

public class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}
```

---

A class access modifier can be either `public` or package-private (no modifier). No other access modifier is allowed.

```java
// Example: Public class
public class ExamplePublic { }

// Example: Package-private class (no modifier)
class ExamplePackagePrivate { }
```

---

## Abstract Class in Java

### Java provides two ways for abstraction:

#### Interface (100% abstraction)
```java
// Interface provides 100% abstraction - all methods are abstract by default
interface Vehicle {
    void start();    // abstract by default
    void stop();     // abstract by default
    void fuel();     // abstract by default
}
```

#### Abstract class (0 to 100% abstraction)
```java
// Abstract class can have both abstract and concrete methods
abstract class Animal {
    // Concrete method (implementation provided)
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
    
    // Abstract method (no implementation)
    abstract void makeSound();
}
```

---

### A class that cannot be instantiated directly

```java
abstract class Shape {
    abstract void draw();
}

public class Main {
    public static void main(String[] args) {
        // Shape s = new Shape(); // ERROR: Cannot instantiate abstract class
        
        // Must create instance of concrete subclass
        Circle c = new Circle();
        c.draw();
    }
}

class Circle extends Shape {
    @Override
    void draw() {
        System.out.println("Drawing a circle");
    }
}
```

---

### Can contain abstract methods (without implementation) and concrete methods (with implementation)

```java
abstract class Employee {
    protected String name;
    protected double salary;
    
    // Concrete method with implementation
    public void displayInfo() {
        System.out.println("Name: " + name + ", Salary: " + salary);
    }
    
    // Abstract method without implementation
    abstract void calculateBonus();
    
    // Another concrete method
    public void work() {
        System.out.println(name + " is working");
    }
}

class Manager extends Employee {
    @Override
    void calculateBonus() {
        salary += salary * 0.2; // 20% bonus for managers
    }
}
```

---

### Declared using the `abstract` keyword

```java
// Abstract class declaration
abstract class Database {
    abstract void connect();
    abstract void disconnect();
}

// If a class has even one abstract method, it must be declared abstract
abstract class FileHandler {
    // Concrete method
    public void openFile(String filename) {
        System.out.println("Opening file: " + filename);
    }
    
    // Abstract method - requires class to be declared 'abstract'
    abstract void processFile();
}

// This would be a COMPILATION ERROR - cannot have abstract method in concrete class
/*
class InvalidClass {
    abstract void someMethod(); // ERROR: abstract methods only allowed in abstract classes
}
*/
```

---

### Used to provide a common base for subclasses

```java
abstract class GameCharacter {
    protected String name;
    protected int health;
    
    public GameCharacter(String name, int health) {
        this.name = name;
        this.health = health;
    }
    
    // Common method for all characters
    public void displayStats() {
        System.out.println(name + " - Health: " + health);
    }
    
    // Each character type will have different attack implementation
    abstract void attack();
}

class Warrior extends GameCharacter {
    public Warrior(String name) {
        super(name, 100);
    }
    
    @Override
    void attack() {
        System.out.println(name + " swings sword!");
    }
}

class Monk extends GameCharacter {
    public Monk(String name) {
        super(name, 80);
    }
    
    @Override
    void attack() {
        System.out.println(name + " casts spell!");
    }
}
```

---

### Can have constructors, fields, and methods like a regular class


---

### An abstract class can extend another abstract class

```java
// First abstract class
abstract class Vehicle {
    abstract void start();
    abstract void stop();
}

// Abstract class extending another abstract class
abstract class LandVehicle extends Vehicle {
    // Can add more abstract methods
    abstract void drive();
    
    // Can provide implementation for parent's abstract methods
    @Override
    void start() {
        System.out.println("Land vehicle starting engine");
    }
    
    // Can add concrete methods
    public void park() {
        System.out.println("Vehicle parked");
    }
}

// Another abstract class extending LandVehicle
abstract class MotorVehicle extends LandVehicle {
    abstract void refuel();
    
    // Implementing remaining abstract method from Vehicle
    @Override
    void stop() {
        System.out.println("Motor vehicle engine stopped");
    }
}

// Concrete class implementing all abstract methods
class Car extends MotorVehicle {
    @Override
    void drive() {
        System.out.println("Car is driving on road");
    }
    
    @Override
    void refuel() {
        System.out.println("Car refueling with gasoline");
    }
}
```

---

## Object class in Java
- The `Object` class is the root class of the Java class hierarchy. Every class in Java implicitly extends the `Object` class if no other superclass (basically the direct parent class) is specified.
- It provides several important methods that are inherited by all Java classes, such as `toString()`, `equals()`, `hashCode()`, `clone()`, and others.
- You can override these methods in your own classes to provide custom behavior.
```java
// Example: Object class is the implicit parent of all classes in Java
class Student {
    private String name;
    private int id;

    public Student(String name, int id) {
        this.name = name;
        this.id = id;
    }

    // Overriding toString() from Object class
    @Override
    public String toString() {
        return "Student{name='" + name + "', id=" + id + "}";
    }

    // Overriding equals() from Object class
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Student other = (Student) obj;
        return id == other.id && name.equals(other.name);
    }

    // Overriding hashCode() from Object class
    @Override
    public int hashCode() {
        return name.hashCode() + id;
    }
}

public class Main {
    public static void main(String[] args) {
        Student s1 = new Student("Alice", 101);
        Student s2 = new Student("Alice", 101);

        // toString() is called implicitly when printing the object
        System.out.println(s1); // Output: Student{name='Alice', id=101}

        // equals() checks logical equality
        System.out.println(s1.equals(s2)); // Output: true

        // hashCode() can be used in hash-based collections
        System.out.println(s1.hashCode()); // Output: hash value

        // You may also hold any object in a variable of type Object
        Object obj = new Student("Bob", 102);
        System.out.println(obj.toString()); // Output: Student{name='Bob', id=102}
    }
}
```

---

## Nested Class in Java
- A nested class is a class defined within another class. 
- When to use nested classes:
  - To logically group related classes in a single file. 
  - To increase encapsulation.
- Scope of nested class will be exactly same as the scope of the outer class.
- Types of nested classes:
  1. Static Nested Class
  2. Non-static Nested Class (Inner Class)
     - Member Inner Class
     - Local Inner Class
     - Anonymous Inner Class
- Just watch the lec starting at 18:38 much easier there